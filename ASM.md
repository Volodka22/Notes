# Ассемблер (Скаков)

## Про курс

Все мы знаем, что ассемблер - просто мнемоническая запись какой-то isa (их много). Наш курс - asm x86. 

## Где используются знания?

1) Антивирусы и вирусы. 
2) Небольшие кусочки операционных систем для которых не существует функций вызова высокого порядка. 
3) Оптимизация C/C++. Ну и отладка...
4) Проще править бинарник, чем перекомпилировать.

## Чем асм лучше бинарника?
В двоичном коде используются ссылки на сколько-то байтиков -> при вставлении кода в середину программы будет коллапс.

## Команды

Несколько синтаксисов: "Нормальный" - Intel и "Гнусный". 

**nasm/yasm:** - с нормальным синтаксисом :)

То что выдаст компилятор - объектный файл. Это значит, что часть можно написать на C, а часть на asm, а потом линк.

## Регистры

Традиционные регистры **i8086** (название микросхем от интел) общего назначения (те, где можно что-то посчитать):
ax - аккумулятор
bx - базовый (учатвовал в адреации)
cx - counter (посчитать число итераций чего-то) 
dx - расширение аккумулятора
sp
bp
si
di

Первые 4 регистра делятся на 8битные: ax = ah + al.

## хронология intel
i8086 (i8088) : i8088 просто чуть слабее железо, никакого исторического вклада.
i80186
i80286
i80386
i80486
i80586

Гарантируется полная совместимость "баг в баг": если функция как-то странно работала, то можно не волноваться - так странно и работает :) . Такая 
совместимость выгодна и пользователю (не нужно переписывать программы) и производителю (можно убедить купить новые процессоры). Костыли, которые 
приходится громаздить замедляют компьютер, но не сильно.

### i80386
Появились 32ух битные процессоры.

eax 
ebx 
ecx  
edx 
esp
ebp
esi
edi

Пропала связь между регистрами и их назначением.

### eflags

zf - регитр нулевой
sf - флаг знака и фиктивно равен старшему разряду
cf - перенос из старшего разряда или заем из старшего заряда

## MOVE

```mov куда, что```
Пример: 
```
mov eax, ebx
mov cl, ch
mov ax, 0
```
Важно: размерности регистров совпадают лево-право

```
mov al, [eax] // записываем значение, находящееся по адресу eax.
```

Может быть не больше одних скобочек на команду.

### Адресация

16 бит: **[bx/bp + si/di + offset 16]**
32 бита: **[eax/ebx/ecx/edx/ebp/esp/esi/edi + любой кроме esp * 1/2/4/8 + offset 32]**

Размеры: byte, word, dword, qword [только в 64 битном мире], dqword = oword, tbyte 

``` move word [eax], 3 ```

## Команды

movezx/movesx - загрузить маленькое в большое

bswap - реверсит биты (типа конверсия между литл эндиан и биг эндиан)

xchg eax, ebx - свапает значения и гарантирует атамарность переменной, но свап по памяти - зло

cmov (cmovz/cmovnc...): выполняет копирование если флаг... Пример cmovz - копирует, если установлен флаг нуля. Работает средне быстро

lea reg, [] - для быстрой арифметики

push/pop - рабта со стеком. Стек растет вниз. Соответственно push уменьшает esp на 4 (в 32 битной)
```push eax```

pusha - загрузить все 8 регистров, popa - читает 7 (все кроме esp)

cwd/cdq: (ax/eax) -> dx:ax/edx:eax

cbw/cwde: (al->ax)/(ax->eax)

in/out - для драйверов (секретно)

Читать про команды множно в **instruction manual**

## Арифметика

```
ADD eax, ebx // +=
SUB eax, ebx // -=
```
ADC и SBB тоже самое, но еще добавляет/вычитает знак переноса

Сложение двух 64битных чисел:
```
edx:eax
ebx:ecx
ADD eax, ecx
ADC edx, ebx
```

MUL ecx - берется eax * op32 -> edx:eax

DIV ecx - edx:eax / op32 -> частное в eax, остаток в edx. Если частное не получается впихать, то падаем с той же ошибкой, что и при деленении на 0.

IMUL/IDIV:
```
IMUL op, op2 // *=
IMUL op, op2, const // op = op2 * const
```




