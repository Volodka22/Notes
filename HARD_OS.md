# Hard OS (by Aleksei Romanovskii)
## Определение операционной системы. Отличие между ОС и ядром ОС. 
**Операционная система (ОС)** — это системное программное обеспечение, которое
управляет аппаратным обеспечением компьютера, программными ресурсами и
предоставляет общие службы для компьютерных программ.

**Ядро** — это часть операционной системы, которая обеспечивает доступ к системным ресурсам. Оно отвечает за то, чтобы несколько приложений могли эффективно совместно использовать оборудование, контролируя доступ к процессору, памяти, дисковому вводу-выводу и сетевому взаимодействию.

**Операционная система** — это ядро ​​и приложения, которые позволяют пользователям выполнять какие-либо действия (например, компилятор, текстовый редактор, оконный менеджер и т. д.).

## Базовые определения и концепции
- **Драйверы устройств** - самый близкий слой к железу. Абстрагирует особенности железа, предоставляя обощенный интерфейс для вызовов.
- **Слой системных вызовов** - унифицирует доступ к функциям операционной системы


## Общая архитектура ОС
<img width="900" height="500" alt="image" src="https://github.com/user-attachments/assets/18c3b4c0-5f34-4681-a784-8b090a7b7793">

## Системные вызовы
- Системные вызовы являются частью API ядра. Они являются границей, где режим выполнения переключается с пользовательского режима на режим ядра
- Системные вызовы редко изменяются. Linux особенно строго это обеспечивает (в отличие от API ядра, которые могут меняться по мере необходимости)
- Сам код ядра может быть логически разделен на код основу ядра и код драйверов устройств. Код драйверов устройств отвечает за доступ к определенным устройствам, в то время как код основы является общим. Основа ядра может быть далее разделена на несколько логических подсистем (например, доступ к файлам, сетевое взаимодействие, управление процессами и т. д.)

## Режимы (modes) исполнения в ОС
- **Hypervisor mode** (монитор виртуальной машины) для запуска виртуальных машин (ОС) внутри ОС
- **Kernel mode** — для запуска кода с более высокими привилегиями, в то время как пользовательский режим означает запуск приложений с более низкими привилегиями
- Код, работающий в режиме ядра, может полностью контролировать CPU, в то время как код, работающий в пользовательском режиме, имеет определенные ограничения. Например, прерывания CPU могут быть отключены или включены только во время работы в режиме ядра. Если прерывание будет предпринято в пользовательском режиме, будет сгенерировано исключение, и ядро ​​его обработает
- Кроме того, HW предоставляет ограничения (защитные кольца) на порты ввода-вывода и инструкции CPU

## Пространства памяти в ОС
- **Kernel space** защищено от доступа, пользовательские приложения не могут получить к нему прямой доступ, в то время как к пользовательскому пространству можно получить прямой доступ из кода режима ядра
- **Physical and virtual** (paging/protected mode) memory

## Монолитное и микро-ядро ОС – различия
### Монолитное
<img width="513" alt="image" src="https://github.com/user-attachments/assets/671f88f7-e2fe-4a46-b0ea-aa0274005250">

- нет защиты доступа между различными подсистемами ядра
- логическое разделение между подсистемами, например, между основным ядром и драйверами устройств с относительно строгими API

_Осуствие защиты между модулями даёт минимальные накладные расходы (оптимальная скорость для современного железа)_

### Микро-ядро
<img width="449" alt="image" src="https://github.com/user-attachments/assets/5e162f80-c473-47b1-8e01-eeace8efdcc6">

- В микроядре большие части ядра защищены друг от друга, обычно работая как службы в пространстве пользователя
- Ядро ​​содержит код для передачи сообщений между процессами и несколько других вещей.
- Защита памяти между службами — но за счет производительности

_Если какой-то модуль отваливается, то его можно перезапустить, не перезапуская всю систему (удобство)_

## Реализации мульти-обработки в ОС
- ОС, которая поддерживает параллельное («одновременное») выполнение нескольких
процессов
- Реализуется путем переключения между запущенными процессами, чтобы позволить процессу
сделать что-то полезное

## Различие между кооперативным и вытесняющей (preemptive) мульти-обработкой
- Кооперативная (не вытесняющая) — процессы взаимодействуют для достижения многозадачности.
Процесс будет запущен и передаст управление ЦП обратно ОС, которая затем
запланирует другой процесс
- Вытесняющая — ядро ​​будет применять временные ограничения для каждого процесса, так что все процессы
имеют шанс. Каждому процессу разрешено выполнять временной отрезок (например, 100 мс), после которого, если он все еще работает, он вытесняется и планируется другой процесс

## Кооперативные ядра (на примере Линукса)
- Процесс продолжает работать до тех пор, пока не завершит обработку обработчика выполнения или добровольно не освободит ЦП.
- Он менее подходит для программирования в реальном времени по сравнению с вытесняющим ядром.
- Каждая задача явно отказывается от управления ЦП.
- Как правило, не допускает вытеснения процесса, работающего в режиме ядра.
- Время отклика недетерминировано и менее отзывчиво по сравнению с вытесняющим ядром.
- Высокоприоритетная задача может ждать долгое время.
- Общие данные обычно требуют семафоров.
- Он может использовать нереентерабельный код.
- Проектировать невытесняющие ядра проще по сравнению с вытесняющими ядрами
- Он менее безопасен и менее полезен в реальных сценариях

## Вытесняющие ядра (на примере Линукса, начиная с версии 2.6 и выше)
- Любой процесс может быть немедленно вытеснен (приостановлен).
- Более подходит для программирования в реальном времени по сравнению с ядрами без вытеснения.
- Высокоприоритетная задача, готовая к запуску, получает управление ЦП.
- Обычно допускает вытеснение даже в режиме ядра.
- Время отклика детерминировано, и оно более отзывчиво по сравнению с ядром без вытеснения.
- Высокоприоритетная задача становится готовой, текущая запущенная задача приостанавливается и перемещается в конец очереди готовых задач.
- Не требует семафоров (ожидание, пробуждение). Ну, почти...
- Не может использовать нереентерабельный код.
- Спроектировать вытесняющие ядра сложнее по сравнению с ядром без вытеснения.
- Он более безопасен и более полезен в реальных сценариях.

## Ассиметричная мульти-обработка (Asymmetric multi-processing)
<img width="818" alt="image" src="https://github.com/user-attachments/assets/d5261dea-8960-4a3b-8788-1a8c034fce01">
Плюс: очень простая архитектура

## Cиметричная мульти-обработка (symmetric multi-processing)
<img width="806" alt="image" src="https://github.com/user-attachments/assets/43038dbe-afc8-4c57-a5a6-018c966a2b70">
Плюс: позволяет распараллелить процессы в Kernel

## Адресные пространства памяти – физическое и виртуальное
- Физическое адресное пространство
  - Физическая оперативная память и периферийная память
- Виртуальное адресное пространство
  - Как процессор видит память в защищенном/страничном режиме выполнении
процессов
  - Ядро ОС отвечает за настройку сопоставления с виртуальным адресным пространством, где
виртуальные страницы сопоставлены с физическими страницами
  - Адресное пространство процесса является (частью) виртуального адресного пространства, связанного с
процессом. Это непрерывная область, которая начинается с нуля
  - Адресное пространство ядра — оперативная память и периферийные устройства как они есть
  - Ядро и пользователь совместно используют часть виртуального пространства



