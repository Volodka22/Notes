# Hard OS (by Aleksei Romanovskii)
## Определение операционной системы. Отличие между ОС и ядром ОС. 
**Операционная система (ОС)** — это системное программное обеспечение, которое
управляет аппаратным обеспечением компьютера, программными ресурсами и
предоставляет общие службы для компьютерных программ.

**Ядро** — это часть операционной системы, которая обеспечивает доступ к системным ресурсам. Оно отвечает за то, чтобы несколько приложений могли эффективно совместно использовать оборудование, контролируя доступ к процессору, памяти, дисковому вводу-выводу и сетевому взаимодействию.

**Операционная система** — это ядро ​​и приложения, которые позволяют пользователям выполнять какие-либо действия (например, компилятор, текстовый редактор, оконный менеджер и т. д.).

## Базовые определения и концепции
- **Драйверы устройств** - самый близкий слой к железу. Абстрагирует особенности железа, предоставляя обощенный интерфейс для вызовов.
- **Слой системных вызовов** - унифицирует доступ к функциям операционной системы


## Общая архитектура ОС
<img width="900" height="500" alt="image" src="https://github.com/user-attachments/assets/18c3b4c0-5f34-4681-a784-8b090a7b7793">

## Системные вызовы
- Системные вызовы являются частью API ядра. Они являются границей, где режим выполнения переключается с пользовательского режима на режим ядра
- Системные вызовы редко изменяются. Linux особенно строго это обеспечивает (в отличие от API ядра, которые могут меняться по мере необходимости)
- Сам код ядра может быть логически разделен на код основу ядра и код драйверов устройств. Код драйверов устройств отвечает за доступ к определенным устройствам, в то время как код основы является общим. Основа ядра может быть далее разделена на несколько логических подсистем (например, доступ к файлам, сетевое взаимодействие, управление процессами и т. д.)

## Режимы (modes) исполнения в ОС
- **Hypervisor mode** (монитор виртуальной машины) для запуска виртуальных машин (ОС) внутри ОС
- **Kernel mode** — для запуска кода с более высокими привилегиями, в то время как пользовательский режим означает запуск приложений с более низкими привилегиями
- Код, работающий в режиме ядра, может полностью контролировать CPU, в то время как код, работающий в пользовательском режиме, имеет определенные ограничения. Например, прерывания CPU могут быть отключены или включены только во время работы в режиме ядра. Если прерывание будет предпринято в пользовательском режиме, будет сгенерировано исключение, и ядро ​​его обработает
- Кроме того, HW предоставляет ограничения (защитные кольца) на порты ввода-вывода и инструкции CPU

## Пространства памяти в ОС
- **Kernel space** защищено от доступа, пользовательские приложения не могут получить к нему прямой доступ, в то время как к пользовательскому пространству можно получить прямой доступ из кода режима ядра
- **Physical and virtual** (paging/protected mode) memory

## Монолитное и микро-ядро ОС – различия
### Монолитное
<img width="513" alt="image" src="https://github.com/user-attachments/assets/671f88f7-e2fe-4a46-b0ea-aa0274005250">

- нет защиты доступа между различными подсистемами ядра
- логическое разделение между подсистемами, например, между основным ядром и драйверами устройств с относительно строгими API

_Осуствие защиты между модулями даёт минимальные накладные расходы (оптимальная скорость для современного железа)_

### Микро-ядро
<img width="449" alt="image" src="https://github.com/user-attachments/assets/5e162f80-c473-47b1-8e01-eeace8efdcc6">

- В микроядре большие части ядра защищены друг от друга, обычно работая как службы в пространстве пользователя
- Ядро ​​содержит код для передачи сообщений между процессами и несколько других вещей.
- Защита памяти между службами — но за счет производительности

_Если какой-то модуль отваливается, то его можно перезапустить, не перезапуская всю систему (удобство)_

## Реализации мульти-обработки в ОС
- ОС, которая поддерживает параллельное («одновременное») выполнение нескольких
процессов
- Реализуется путем переключения между запущенными процессами, чтобы позволить процессу
сделать что-то полезное

## Различие между кооперативным и вытесняющей (preemptive) мульти-обработкой
- Кооперативная (не вытесняющая) — процессы взаимодействуют для достижения многозадачности.
Процесс будет запущен и передаст управление ЦП обратно ОС, которая затем
запланирует другой процесс
- Вытесняющая — ядро ​​будет применять временные ограничения для каждого процесса, так что все процессы
имеют шанс. Каждому процессу разрешено выполнять временной отрезок (например, 100 мс), после которого, если он все еще работает, он вытесняется и планируется другой процесс




