# Многопоточное программирование

## Введение и мотивация

### Зачем нам это?

Все вычислительные машины - многоядерные (от веба до android). Закон Мура и "The free lunch is over": частота ядра стабилизировалась с 2005 года, 
рост производительности ядер начала меньше расти (не exp). Решение? 2005 год - начало эпохи многопоточности!!!

Масштабирование: с ростом кол-ва ядер скорость растет не пропорционально. 
Закон Амдала: ускорение кода S = 1 / (1 - P + P/N), где N - число потоков, P - доля параллельного кода. 

У параллелизма на уровне инструкций есть предел -> ПарПрог

### Мультипроцессорность

Симметричная мультипроцессорность (SMP) - Два (или больше) ядра, на каждый свой поток. 
Узкое место - синхронизация большого числа вычислений (например, проигрыш в хешах)

Одновременная многозадачность (SMT) - два (или более) потока выполняется на одном вычислительном ядре. Для программиста выглядит как SMP :/

Ассиметричный доступ к памяти (NUMA): Память1 <-> CPU1 <-> CPU2 <-> Память2 (чтобы обратиться к памяти, нужно задействовать определнный процессор.
Модель программирования такая же, что и в SMP - общая память.

### Операционные системы

Типы:
- Однозначные
- Система с пакетнымм заданиями (batch processing). Процессы выполняются пакетами, поочередно
- Многозадачные / с разделением времени.
  - Кооперативная многозадачность. Выполняет инструкции с того терминала, где уже написана инструкция.
  - Вытесняющая многозадачность. Твой код может быть вытеснен в произвольный момент
  
### Основные понятия
- Процесс - владеет памятью и ресурсами. ОС создают иллюзию, что у процесса есть своя отдельная машина, у которой много ядер.
- Поток - контекст исполнения внутри процесса
  - В одном процессе может быть несколько потоков
  - Все потоки работают с общей памятью процесса
 
### Модели программирования
- Однопоточное / однозадачное
- Многозадачное
  - Модель с общей памятью. Она и будет рассмотрена в этом курсе
  - Модель с передачей сообщений (распределенное сообщение)
  
### Модель с общей памятью
#### Общие объекты 
- Потоки выполняют операции над общими объектами
- Не важны операции внутри потоков
- Важна только коммуникация между потоками
- Единственный тип коммуникации между потоками - работа с общими объектами
#### Общие переменные
- Это простейший тип общения
  - Есть значения определенного типа
  - Есть read and write
- Это базовые строительные блоки
- Хорошая абстракция

## Определения и формализм
### Модель произошло до
- Исполнение системы - пара (H, ->)
- "Произошло до" - это частичный строгий порядок (транзитивное, антирефлексивное, асимметричное)
- e -> f означает, что e произошло до f
- Две операции e и f параллельны, если не e -> f и не f -> e
- Операция (сложная) состоит из двух событий (простых):
  - inv(e) - вызов операции
  - res(e) - ответ на операцию (результат)
  - Все события упордочены через знак '<'
- e -> f, тогда и только когда res(e) < inv(e).
- Распологаем inv(e) и res(e) на числовой оси, тогда каждая операция - это числовой интервал
### Система
- Набор всевозможных исполнений системы
- Говорим, что "система имеет свойство P", если каждое исполнение системы имеет свойство P
### Конфликты и гонки
- Две конфликтующие оперции - это read-write или write-write (не коммутирующие). Read-read не конфликтует за ячейку памяти.
- Если две конфликтующие операции произошли параллельно - то это называется гонка данных. (свойство конкретного исполнения)
- Если в программе не может произойти гонок ни в одном из исполнений, то такая программа называется синхроннизированной.
- Исполнение называется правильным,если его сужение на каждый поток P является последовательным.
### Допустимость
- Последовательное исполнение допустимо - если выполнены последовательные спецификации всех объектов (Например, записали 1 и прочитали 1, иначе no legal)
- Условия согласовнности (для параллельных)
  - Составим эквивалентное допустимое последовательное исполнение
  - Как именно - тут есть варианты: условия согласованности
    - Последовательная согласованности
    - Линеризуемость
### Последовательная согласованность
- Исполнение последовательно согласованно, если можно сопоставить последовательное исполнение с сохранением порядка операций на каждом потоке (программный порядок)
- Не влечет согласованность на всем исполнении :(
### Линеризация
- Линеризуемо - можно сопоставить эквивалентное допустимое последовательное исполнение с сохранием "произошло до"
- Линеризуемо исполнение <-> Линериазуемо исполнение на каждом объекте отдельно.
- Операции над линеризуемыми объектами называют атомарными
- Исполнение системы,выполняещей операции над атомарными объектами, можно анализировать в модели чередования.
- Доказав атомарность сложного объекта можно абстрагироваться от деталей реализации и считать операции атомарными
- Когда говорят, что объект безопасен -> атомарен (иные условия приводят явно)
- Точки линеризации - каждой операции сопоставлено одно событие, заданное вместе с линеризацией
- Можно найти точки линеризации и полный порядок над ними, который согласован с частичным порядком и линеризацией. 
- В программу всегда можно добавить новую операцию (точку линеризации), для достижения линеризации
